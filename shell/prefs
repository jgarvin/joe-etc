#!/bin/sh

. `dirname $0`/util

# Load OS specific preferences
if [[ -a `dirname $0`/$(uname -s) ]]; then
    . `dirname $0`/$(uname -s)
else
    echo "No shell preferences found for this OS!" >&2
fi

export ANDROID_PATH=~/opt/android-sdk-linux_x86-1.6_r1;
if [[ -d $ANDROID_PATH ]]; then
	export PATH=$(path_prepend $ANDROID_PATH/tools)
fi

if [[ -d "$HOME/opt/bin" ]]; then
 	export PATH=$(path_prepend "$HOME/opt/bin")
fi

if [ -d $HOME/opt/lib/python2.6/site-packages ]; then
    export PYTHONPATH=$HOME/opt/lib/python2.6/site-packages:$PYTHONPATH
fi

# Ack is a nice replacement for grep, just does the right thing
# Really should be able to add to the existing make type, but will make mk a separate
# type for now.
ack()
{
	~/etc/bin/ack \
	        --sort-files \
		--type-set incl=.incl \
		--type-add hh=.ipp "$@";
}

export BROWSER="$ZDOTDIR/etc/bin/launch-my-browser"

# Newer versions of emacs will autoload emacs if ALTERNATE_EDITOR is empty.
export EDITOR="$ZDOTDIR/etc/bin/launch-emacs"

if which htop > /dev/null; then
    alias top='htop'
fi

if grep --version 2> /dev/null | grep GNU &> /dev/null
then
    alias grep='grep --color=auto'
fi

if ls --version 2> /dev/null | grep GNU &> /dev/null
then
    alias ls='ls -F -h --color=auto --group-directories-first'
fi

# Obey my typos!
alias -r sl=ls

# Don't clear the screen when less exits
# also, searching should start from last line of screen
alias less='less -X -a'

alias ipython="ipython -colors Linux -noconfirm_exit -nobanner"

# Harmless over LAN on modern CPUs, and very useful when logged into london.
alias ssh="ssh -C -X"

# almost never use mv to overwrite
alias mv="mv -i"

# 99% of the time I want truss to include child processes
file_name=$0

if which truss &> /dev/null; then
    truss()
    {
        echo "Running truss including children. See $file_name."
        disable -f truss
        truss -f "$@"
        enable -f truss
    }
fi

# Without this OO looks terrible under xmonad
OOO_FORCE_DESKTOP=gnome

# Add sensible bindings for ocaml
if which rlwrap &> /dev/null
then
	if which ocaml &> /dev/null
	then
		alias ocaml='rlwrap ocaml'
	else
		echo "rlwrap not available, so you're stuck with bare ocaml." >&2
	fi
fi

if [[ "$(basename $ZDOTDIR)" = "$LOGNAME" ]];
then
    # Although we haven't added $HOME/etc/bin to our path yet,
    # if we're a subshell we may inherit it. We want to remove
    # it temporarily because we're going to find the 'real'
    # locations of different utilities.
    PATH=$(echo $PATH | sed s,$HOME/etc/bin,,g | sed s,$HOME/etc/bin/$(uname -s),,g)

    # Protect against having '.' in $PATH.
    # zsh interprets '::' in $PATH to mean ':.:'
    # This can happen after removing paths above.
    PATH=$(echo $PATH | sed 's/::/:/g')

    if [[ ! -a $HOME/etc/real_locations/$(hostname) ]]; then
        mkdir -p $HOME/etc/real_locations/$(hostname)
    fi

    which gdb > $HOME/etc/real_locations/$(hostname)/gdb
    which svcadm > $HOME/etc/real_locations/$(hostname)/svcadm

    # OK, now put it back in.
    if [[ -d $ZDOTDIR/etc/bin ]]; then
	    PATH=$(path_prepend $ZDOTDIR/etc/bin)
	    os_bin="$ZDOTDIR/etc/bin/$(uname -s)"
	    mkdir -p "$os_bin"
	    PATH=$(path_prepend "$os_bin")
    fi
fi

sshmount() {
    remote_path="$ZDOTDIR/remote/$1-root"

    # create mount point
    mkdir -p "$remote_path"

    # apparently these are best for performance
    sshfs_opts="-oreconnect,transform_symlinks,ssh_command=$ZDOTDIR/etc/bin/ssharcfour"
		#sshfs_opts="-o ssh_command=$ZDOTDIR/etc/bin/ssharcfour"

    # Remount
    fusermount -u "$remote_path" &> /dev/null
    if ! sshfs "$sshfs_opts" "$LOGNAME"@"$1":/ "$remote_path"; then
				echo >&2 "sshfs failed!"
				return 1
		fi

    cd $ZDOTDIR/remote
    ln -Tsf "$1-root/home/$LOGNAME" "$1"

    # make future instances passwordless
    ssh-add &> /dev/null # idempotent, registers key
		mkdir -p "$1-root/home/$LOGNAME/.ssh"
		remote_key_file="$1-root/home/$LOGNAME/.ssh/authorized_keys"
		if ! grep "$(cat $ZDOTDIR/.ssh/id_rsa.pub)" $remote_key_file &> /dev/null; then
				cat $ZDOTDIR/.ssh/id_rsa.pub >> $remote_key_file
		fi

		# make sure ssh'ing to self is passwordless
		local_key_file="$ZDOTDIR/.ssh/authorized_keys"
		if ! grep "$(cat $ZDOTDIR/.ssh/id_rsa.pub)" $local_key_file  &> /dev/null; then
				cat $ZDOTDIR/.ssh/id_rsa.pub >> $local_key_file
		fi
}

if [ -d $ZDOTDIR/jsh ]; then
    source $ZDOTDIR/jsh/init.zsh
fi

export MAKEFLAGS="-j"

export PATH
