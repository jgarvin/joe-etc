#!/bin/sh

########################################
##### script utility functions     #####
########################################

path_append() {
    # Only append a path if it's not already present
    if [ -d "$1" ]; then
        if [[ ":$PATH:" != *":$1:"* ]]; then
            export PATH="$PATH:$1"
        fi
    else
        echo "Error, tried to prepend path $1 but it doesn't exist." >&2
        return 1
    fi
}

path_prepend() {
    # Only prepend a path if it's not already present
    if [ -d "$1" ]; then
        if [[ ":$PATH:" != *":$1:"* ]]; then
            export PATH="$1:$PATH"
        fi
    else
        echo "Error, tried to prepend path $1 but it doesn't exist." >&2
        return 1
    fi
}

tsk()
{
 	# We filter out grep from the list of processes so
	# long as grep isn't the process we're actually trying
	# to see running
	if expr match $1 "grep" > /dev/null
	then
		ps_crossplatform | grep -i $@;
	else
		ps_crossplatform | grep -i $@ | grep -v grep;
	fi
}

error()
{
	if test -n "$DISPLAY"
	then
		if which xmessage > /dev/null;
		then
			xmessage "Error: " $@ > /dev/null;
			return 0;
		fi
	else
		echo "Error: " $@ >&2;
	fi
}

is_symlink()
{
	if test -e $1
	then
		if test -L $1
		then
			echo -n '' > /dev/null;
		else
			error "$1 isn't a symlink.";
			return 1;
		fi
	fi

	return 0;
}

try_apps()
{
	for app in "$@"
	do
		app_no_opts="$(echo $app | cut -d ' ' -f 1)";
		if which $app_no_opts > /dev/null;
		then
			eval "$app";
			if test "$?" = "130" -o "$?" = "0" # SIGINT is OK
			then
				break;
			else
				if test "$app" = "$1";
				then
					error "Nonzero exit code from:" $app;
				fi
			fi
		else
			if test "$app" = "$1";
			then
				error "Could not find:" $1;
			fi
		fi
	done
}

# Tries harder and harder to kill a process,
# but starts the nice way.
nice_kill()
{
	to_kill=$1

	for sig in INT TERM KILL
	do
		echo "Trying SIG$sig on $to_kill"
		kill -$sig $to_kill;
		if (! ps $to_kill );
		then
			echo "Killed successfully."
			return 0;
		fi
		sleep 1;
	done

	echo "Could not kill!"
	return 1;
}

# ALL of the children of a pid
if which pstree > /dev/null
then
	pid_children()
	{
		pstree -p $1 | egrep -o '\([0-9]+\)' | tr -d '()'
	}
elif which ptree > /dev/null
then
	# Need to actually test this on Solaris
	pid_children()
	{
		ptree $1 | awk '{ print $1 }'
	}
fi

# Tries killing a process the nice way, by name.
# Will NOT commit suicide.
nice_pkill()
{
	echo "Killing processes with name $1 avoiding children of "$MAIN_SCRIPT_PID

	suicide_regex="("
	first="true"
	for child in $(pid_children $MAIN_SCRIPT_PID)
	do
		if test $first = "true"
		then
			first="false"
		else
			suicide_regex=$suicide_regex"|"
		fi
		suicide_regex=$suicide_regex$child
	done
	suicide_regex=$suicide_regex")"

	echo "Pid finding command: pgrep $1 | egrep -v $suicide_regex"
	to_kill=$(pgrep $1 | egrep -v "$suicide_regex" | grep -v $$ );

	echo "Going to kill: "$to_kill

	pgrep $1 | egrep -v $suicide_regex

	if test "$to_kill" != ""
	then
		nice_kill $to_kill;
	fi
}

